package selectivedeployment

import (
	"fmt"
	"os"
	"os/signal"
	"reflect"
	"strings"
	"sync"
	"syscall"
	"time"

	selectivedeployment_v1 "headnode/pkg/apis/selectivedeployment/v1alpha"
	"headnode/pkg/authorization"
	selectivedeploymentinformer_v1 "headnode/pkg/client/informers/externalversions/selectivedeployment/v1alpha"

	log "github.com/Sirupsen/logrus"
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/util/workqueue"
)

// The main structure of controller
type controller struct {
	logger   *log.Entry
	queue    workqueue.RateLimitingInterface
	informer cache.SharedIndexInformer
	handler  HandlerInterface
	wg       map[string]*sync.WaitGroup
}

// The main structure of informerEvent
type informerevent struct {
	key      string
	function string
	delta    string
}

// String literals
const create = "create"
const update = "update"
const delete = "delete"

// Start function is entry point of the controller
func Start() {
	/*clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}*/
	sdClientset, err := authorization.CreateSelectiveDeploymentClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}

	// Create the selectivedeployment informer which was generated by the code generator to list and watch selectivedeployment resources
	informer := selectivedeploymentinformer_v1.NewSelectiveDeploymentInformer(
		sdClientset,
		meta_v1.NamespaceAll,
		0,
		cache.Indexers{},
	)
	// Create a work queue which contains a key of the resource to be handled by the handler
	queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())
	var event informerevent
	// Event handlers deal with events of resources. In here, we take into consideration of adding and updating nodes
	informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			// Put the resource object into a key
			event.key, err = cache.MetaNamespaceKeyFunc(obj)
			event.function = create
			log.Infof("Add selectivedeployment: %s", event.key)
			if err == nil {
				// Add the key to the queue
				queue.Add(event)
			}
		},
		UpdateFunc: func(oldObj, newObj interface{}) {
			if reflect.DeepEqual(oldObj.(*selectivedeployment_v1.SelectiveDeployment).Status, newObj.(*selectivedeployment_v1.SelectiveDeployment).Status) {
				event.key, err = cache.MetaNamespaceKeyFunc(newObj)
				event.function = update
				// The variable of event.delta contains the different values of the old object from the new one
				event.delta = fmt.Sprintf("%s", strings.Join(dry(oldObj.(*selectivedeployment_v1.SelectiveDeployment).Spec.Controller, newObj.(*selectivedeployment_v1.SelectiveDeployment).Spec.Controller), "/?delta?/ "))
				log.Infof("Update selectivedeployment: %s", event.key)
				if err == nil {
					queue.Add(event)
				}
			}
		},
		DeleteFunc: func(obj interface{}) {
			// DeletionHandlingMetaNamsespaceKeyFunc helps to check the existence of the object while it is still contained in the index.
			// Put the resource object into a key
			event.key, err = cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
			event.function = delete
			// The variable of event.delta contains the different values in the same way as UpdateFunc.
			// In addition to that, this variable includes the name, namespace, type, controller of the deleted object.
			event.delta = fmt.Sprintf("%s-?delta?- %s-?delta?- %s-?delta?- %s", obj.(*selectivedeployment_v1.SelectiveDeployment).GetName(), obj.(*selectivedeployment_v1.SelectiveDeployment).GetNamespace(), obj.(*selectivedeployment_v1.SelectiveDeployment).Spec.Type,
				strings.Join(dry(obj.(*selectivedeployment_v1.SelectiveDeployment).Spec.Controller, []selectivedeployment_v1.Controller{}), "/?delta?/ "))
			log.Infof("Delete selectivedeployment: %s", event.key)
			if err == nil {
				queue.Add(event)
			}
		},
	})
	wg := make(map[string]*sync.WaitGroup)
	controller := controller{
		logger:   log.NewEntry(log.New()),
		informer: informer,
		queue:    queue,
		handler:  &SDHandler{},
		wg:       wg,
	}

	// A channel to terminate elegantly
	stopCh := make(chan struct{})
	defer close(stopCh)
	// Run the controller loop as a background task to start processing resources
	go controller.run(stopCh)
	// A channel to observe OS signals for smooth shut down
	sigTerm := make(chan os.Signal, 1)
	signal.Notify(sigTerm, syscall.SIGTERM)
	signal.Notify(sigTerm, syscall.SIGINT)
	<-sigTerm
}

// Run starts the controller loop
func (c *controller) run(stopCh <-chan struct{}) {
	// A Go panic which includes logging and terminating
	defer utilruntime.HandleCrash()
	// Shutdown after all goroutines have done
	defer c.queue.ShutDown()
	c.logger.Info("run: initiating")
	c.handler.Init()
	// Run the informer to list and watch resources
	go c.informer.Run(stopCh)

	// Synchronization to settle resources one
	if !cache.WaitForCacheSync(stopCh, c.hasSynced) {
		utilruntime.HandleError(fmt.Errorf("Error syncing cache"))
		return
	}
	c.logger.Info("run: cache sync complete")
	// Operate the runWorker
	wait.Until(c.runWorker, time.Second, stopCh)
}

// To link the informer's HasSynced method to the Controller interface
func (c *controller) hasSynced() bool {
	return c.informer.HasSynced()
}

// To process new objects added to the queue
func (c *controller) runWorker() {
	log.Info("runWorker: starting")
	// Run processNextItem for all the changes
	for c.processNextItem() {
		log.Info("runWorker: processing next item")
	}

	log.Info("runWorker: completed")
}

// This function deals with the queue and sends each item in it to the specified handler to be processed.
func (c *controller) processNextItem() bool {
	log.Info("processNextItem: start")
	// Fetch the next item of the queue
	event, quit := c.queue.Get()
	if quit {
		return false
	}
	defer c.queue.Done(event)
	// Get the key string
	keyRaw := event.(informerevent).key
	// Use the string key to get the object from the indexer
	item, exists, err := c.informer.GetIndexer().GetByKey(keyRaw)
	if err != nil {
		if c.queue.NumRequeues(event.(informerevent).key) < 5 {
			c.logger.Errorf("Controller.processNextItem: Failed processing item with key %s with error %v, retrying", event.(informerevent).key, err)
			c.queue.AddRateLimited(event.(informerevent).key)
		} else {
			c.logger.Errorf("Controller.processNextItem: Failed processing item with key %s with error %v, no more retries", event.(informerevent).key, err)
			c.queue.Forget(event.(informerevent).key)
			utilruntime.HandleError(err)
		}
	}

	if !exists {
		if event.(informerevent).function == delete {
			c.logger.Infof("Controller.processNextItem: object deleted detected: %s", keyRaw)
			c.handler.ObjectDeleted(item, event.(informerevent).delta)
		}
	} else {
		if event.(informerevent).function == create {
			c.logger.Infof("Controller.processNextItem: object created detected: %s", keyRaw)
			c.handler.ObjectCreated(item)
		} else if event.(informerevent).function == update {
			c.logger.Infof("Controller.processNextItem: object updated detected: %s", keyRaw)
			c.handler.ObjectUpdated(item, event.(informerevent).delta)
		}
	}
	c.queue.Forget(event.(informerevent).key)

	if c.queue.Len() == 0 {
		go c.handler.ConfigureControllers()
	}

	return true
}

// dry function remove the same values of the old and new objects from the old object to have
// the slice of deleted values.
func dry(oldSlice []selectivedeployment_v1.Controller, newSlice []selectivedeployment_v1.Controller) []string {
	var uniqueSlice []string
	for _, oldValue := range oldSlice {
		exists := false
		for _, newValue := range newSlice {
			if oldValue.Type == newValue.Type && oldValue.Name == newValue.Name {
				exists = true
			}
		}
		if !exists {
			uniqueSlice = append(uniqueSlice, fmt.Sprintf("%s?/delta/? %s", oldValue.Type, oldValue.Name))
		}
	}
	return uniqueSlice
}
