package selectivedeployment

import (
	"fmt"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	geolocation_v1 "headnode/pkg/apis/geolocation/v1alpha"
	"headnode/pkg/authorization"
	geolocationinformer_v1 "headnode/pkg/client/informers/externalversions/geolocation/v1alpha"

	log "github.com/Sirupsen/logrus"
	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/apimachinery/pkg/util/wait"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/cache"
	"k8s.io/client-go/util/workqueue"
)

// The main structure of controller
type controller struct {
	logger    *log.Entry
	clientset kubernetes.Interface
	queue     workqueue.RateLimitingInterface
	informer  cache.SharedIndexInformer
	handler   HandlerInterface
}

// The main structure of informerEvent
type informerevent struct {
	key      string
	function string
	delta    string
}

// Start function is entry point of the controller
func Start() {
	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	geolocationClientset, err := authorization.CreateGeoLocationClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}

	// Create the geolocation informer which was generated by the code generator to list and watch geolocation resources
	informer := geolocationinformer_v1.NewGeoLocationInformer(
		geolocationClientset,
		meta_v1.NamespaceAll,
		0,
		cache.Indexers{},
	)
	// Create a work queue which contains a key of the resource to be handled by the handler
	queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())
	var event informerevent
	// Event handlers deal with events of resources. In here, we take into consideration of adding and updating nodes
	informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			// Put the resource object into a key
			event.key, err = cache.MetaNamespaceKeyFunc(obj)
			event.function = "create"
			log.Infof("Add geolocation: %s", event.key)
			if err == nil {
				// Add the key to the queue
				queue.Add(event)
			}
		},
		UpdateFunc: func(oldObj, newObj interface{}) {
			event.key, err = cache.MetaNamespaceKeyFunc(newObj)
			event.function = "update"
			// The variable of event.delta contains the different values of the old object from the new one
			event.delta = strings.Join(dry(oldObj.(*geolocation_v1.GeoLocation).Spec.Value, newObj.(*geolocation_v1.GeoLocation).Spec.Value), "- ")
			log.Infof("Update geolocation: %s", event.key)
			if err == nil {
				queue.Add(event)
			}
		},
		DeleteFunc: func(obj interface{}) {
			// DeletionHandlingMetaNamsespaceKeyFunc helps to check the existence of the object while it is still contained in the index.
			// Put the resource object into a key
			event.key, err = cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
			event.function = "delete"
			// The variable of event.delta contains the different values in the same way as UpdateFunc.
			// In addition to that, this variable includes the type values and the namespace of the deleted object.
			event.delta = fmt.Sprintf("%s- %s- %s", obj.(*geolocation_v1.GeoLocation).GetNamespace(), obj.(*geolocation_v1.GeoLocation).Spec.Type, strings.Join(obj.(*geolocation_v1.GeoLocation).Spec.Deployment, "/ "))
			log.Infof("Delete geolocation: %s", event.key)
			if err == nil {
				queue.Add(event)
			}
		},
	})
	controller := controller{
		logger:    log.NewEntry(log.New()),
		clientset: clientset,
		informer:  informer,
		queue:     queue,
		handler:   &GeoHandler{},
	}

	// A channel to terminate elegantly
	stopCh := make(chan struct{})
	defer close(stopCh)
	// Run the controller loop as a background task to start processing resources
	go controller.run(stopCh)
	// A channel to observe OS signals for smooth shut down
	sigTerm := make(chan os.Signal, 1)
	signal.Notify(sigTerm, syscall.SIGTERM)
	signal.Notify(sigTerm, syscall.SIGINT)
	<-sigTerm
}

// Run starts the controller loop
func (c *controller) run(stopCh <-chan struct{}) {
	// A Go panic which includes logging and terminating
	defer utilruntime.HandleCrash()
	// Shutdown after all goroutines have done
	defer c.queue.ShutDown()
	c.logger.Info("run: initiating")

	// Run the informer to list and watch resources
	go c.informer.Run(stopCh)

	// Synchronization to settle resources one
	if !cache.WaitForCacheSync(stopCh, c.hasSynced) {
		utilruntime.HandleError(fmt.Errorf("Error syncing cache"))
		return
	}
	c.logger.Info("run: cache sync complete")
	// Operate the runWorker
	wait.Until(c.runWorker, time.Second, stopCh)
}

// To link the informer's HasSynced method to the Controller interface
func (c *controller) hasSynced() bool {
	return c.informer.HasSynced()
}

// To process new objects added to the queue
func (c *controller) runWorker() {
	log.Info("runWorker: starting")
	// Run processNextItem for all the changes
	for c.processNextItem() {
		log.Info("runWorker: processing next item")
	}

	log.Info("runWorker: completed")
}

// This function deals with the queue and sends each item in it to the specified handler to be processed.
func (c *controller) processNextItem() bool {
	log.Info("processNextItem: start")
	// Fetch the next item of the queue
	event, quit := c.queue.Get()
	if quit {
		return false
	}
	defer c.queue.Done(event)
	// Get the key string
	keyRaw := event.(informerevent).key
	// Use the string key to get the object from the indexer
	item, exists, err := c.informer.GetIndexer().GetByKey(keyRaw)
	if err != nil {
		if c.queue.NumRequeues(event.(informerevent).key) < 5 {
			c.logger.Errorf("Controller.processNextItem: Failed processing item with key %s with error %v, retrying", event.(informerevent).key, err)
			c.queue.AddRateLimited(event.(informerevent).key)
		} else {
			c.logger.Errorf("Controller.processNextItem: Failed processing item with key %s with error %v, no more retries", event.(informerevent).key, err)
			c.queue.Forget(event.(informerevent).key)
			utilruntime.HandleError(err)
		}
	}

	if !exists {
		c.logger.Infof("Controller.processNextItem: object deleted detected: %s", keyRaw)
		c.handler.ObjectDeleted(item, event.(informerevent).delta)
		c.queue.Forget(event.(informerevent).key)
	} else {
		switch event.(informerevent).function {
		case "create":
			c.logger.Infof("Controller.processNextItem: object created detected: %s", keyRaw)
			c.handler.ObjectCreated(item)
			c.queue.Forget(event.(informerevent).key)
		case "update":
			c.logger.Infof("Controller.processNextItem: object updated detected: %s", keyRaw)
			c.handler.ObjectUpdated(item, event.(informerevent).delta)
			c.queue.Forget(event.(informerevent).key)
		default:
			c.logger.Infof("Controller.processNextItem: object created detected: %s", keyRaw)
			c.handler.ObjectCreated(item)
			c.queue.Forget(event.(informerevent).key)
		}
	}
	return true
}

// Dry function remove the same values of the old and new objects from the old object to have
// the slice of different values.
func dry(mainSlice []string, deleteSlice []string) []string {
	var uniqueSlice []string
	for _, mainValue := range mainSlice {
		exists := false
		for _, deleteValue := range deleteSlice {
			if mainValue == deleteValue {
				exists = true
			}
		}
		if !exists {
			uniqueSlice = append(uniqueSlice, mainValue)
		}
	}
	return uniqueSlice
}
