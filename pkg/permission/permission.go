/*
Copyright 2020 Sorbonne UniversitÃ©

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package permission

import (
	"context"
	"fmt"
	"log"
	"strings"

	apps_v1alpha "github.com/EdgeNet-project/edgenet/pkg/apis/apps/v1alpha"

	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// Clientset to be synced by the custom resources
var Clientset kubernetes.Interface

// CreateClusterRoles create or update the cluster role attached to the authority
func CreateClusterRoles(authorityCopy *apps_v1alpha.Authority) error {
	// Create a cluster role to be used by authority users
	policyRule := []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"authorities", "totalresourcequotas"}, ResourceNames: []string{authorityCopy.GetName()}, Verbs: []string{"get"}}}
	authorityRole := &rbacv1.ClusterRole{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("authority-%s", authorityCopy.GetName())}, Rules: policyRule}
	_, err := Clientset.RbacV1().ClusterRoles().Create(context.TODO(), authorityRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create authority-%s role: %s", authorityCopy.GetName(), err)
		if errors.IsAlreadyExists(err) {
			authorityClusterRole, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), authorityRole.GetName(), metav1.GetOptions{})
			if err == nil {
				authorityClusterRole.Rules = policyRule
				_, err = Clientset.RbacV1().ClusterRoles().Update(context.TODO(), authorityClusterRole, metav1.UpdateOptions{})
				if err == nil {
					log.Printf("Authority-%s cluster role updated", authorityCopy.GetName())
					return err
				}
			}
		}
	}
	return err
}

// EstablishPrivateRoleBindings generates role bindings to allow users to access their user objects and the authority to which they belong
func EstablishPrivateRoleBindings(userCopy *apps_v1alpha.User) error {
	// Put the service account dedicated to the user into the role bind subjects
	rbSubjects := []rbacv1.Subject{{Kind: "User", Name: userCopy.Spec.Email, APIGroup: "rbac.authorization.k8s.io"}}
	// This section allows the user to get user object that belongs to him. The role, which gets used by the binding object,
	// generated by the user controller when the user object created.
	roleName := fmt.Sprintf("user-%s", userCopy.GetName())
	roleRef := rbacv1.RoleRef{Kind: "Role", Name: roleName}
	roleBind := &rbacv1.RoleBinding{ObjectMeta: metav1.ObjectMeta{Namespace: userCopy.GetNamespace(), Name: fmt.Sprintf("%s-%s", userCopy.GetNamespace(), roleName)},
		Subjects: rbSubjects, RoleRef: roleRef}
	_, err := Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Create(context.TODO(), roleBind, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create %s role binding in namespace of %s: %s, err: %s", roleName, userCopy.GetNamespace(), userCopy.GetName(), err)
		if errors.IsAlreadyExists(err) {
			userRoleBind, err := Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Get(context.TODO(), roleBind.GetName(), metav1.GetOptions{})
			if err == nil {
				userRoleBind.Subjects = rbSubjects
				userRoleBind.RoleRef = roleRef
				_, err = Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Update(context.TODO(), userRoleBind, metav1.UpdateOptions{})
				if err == nil {
					log.Printf("Updated: role binding in namespace of %s: %s", userCopy.GetNamespace(), userCopy.GetName())
				}
			}
		}
	}
	err = establishAuthoritySpecificBindings(userCopy, rbSubjects)
	return err
}

func establishAuthoritySpecificBindings(userCopy *apps_v1alpha.User, rbSubjects []rbacv1.Subject) error {
	// This section allows the user to get the authority object in which he/she participates. The role, which gets used by the binding object,
	// generated by the authority controller when the authority object created.
	userOwnerNamespace, _ := Clientset.CoreV1().Namespaces().Get(context.TODO(), userCopy.GetNamespace(), metav1.GetOptions{})
	roleName := fmt.Sprintf("authority-%s", userOwnerNamespace.Labels["authority-name"])
	roleRef := rbacv1.RoleRef{Kind: "ClusterRole", Name: roleName}
	clusterRoleBind := &rbacv1.ClusterRoleBinding{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("%s-%s-for-authority", userCopy.GetNamespace(), userCopy.GetName())},
		Subjects: rbSubjects, RoleRef: roleRef}
	_, err := Clientset.RbacV1().ClusterRoleBindings().Create(context.TODO(), clusterRoleBind, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create %s role bindind of %s:%s", roleName, userCopy.GetNamespace(), userCopy.GetName())
		if errors.IsAlreadyExists(err) {
			userClusterRoleBind, err := Clientset.RbacV1().ClusterRoleBindings().Get(context.TODO(), clusterRoleBind.GetName(), metav1.GetOptions{})
			if err == nil {
				userClusterRoleBind.Subjects = rbSubjects
				userClusterRoleBind.RoleRef = roleRef
				_, err = Clientset.RbacV1().ClusterRoleBindings().Update(context.TODO(), userClusterRoleBind, metav1.UpdateOptions{})
				if err == nil {
					log.Printf("Updated: role binding in namespace of %s: %s", userCopy.GetNamespace(), userCopy.GetName())
					return err
				}
			}
		}
	}
	return err
}

// EstablishRoleBindings generates the rolebindings according to user roles in the namespace specified
func EstablishRoleBindings(userCopy *apps_v1alpha.User, namespace string, namespaceType string) error {
	// Put the service account dedicated to the user into the role bind subjects
	rbSubjects := []rbacv1.Subject{{Kind: "User", Name: userCopy.Spec.Email, APIGroup: "rbac.authorization.k8s.io"}}
	// Roles are pre-generated by the controllers
	roleName := fmt.Sprintf("%s-%s", strings.ToLower(namespaceType), strings.ToLower(userCopy.Status.Type))
	roleRef := rbacv1.RoleRef{Kind: "ClusterRole", Name: roleName}
	roleBind := &rbacv1.RoleBinding{ObjectMeta: metav1.ObjectMeta{Namespace: namespace, Name: fmt.Sprintf("%s-%s-%s", userCopy.GetNamespace(), userCopy.GetName(), roleName)},
		Subjects: rbSubjects, RoleRef: roleRef}
	_, err := Clientset.RbacV1().RoleBindings(namespace).Create(context.TODO(), roleBind, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create %s role binding in namespace of %s: %s - %s, err: %s", userCopy.Status.Type, namespace, userCopy.GetNamespace(), userCopy.GetName(), err)
		if errors.IsAlreadyExists(err) {
			userRoleBind, err := Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Get(context.TODO(), roleBind.GetName(), metav1.GetOptions{})
			if err == nil {
				userRoleBind.Subjects = rbSubjects
				userRoleBind.RoleRef = roleRef
				_, err = Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Update(context.TODO(), userRoleBind, metav1.UpdateOptions{})
				if err == nil {
					log.Printf("Updated: %s role binding in namespace of %s: %s - %s", userCopy.Status.Type, namespace, userCopy.GetNamespace(), userCopy.GetName())
					return err
				}
			}
		}
	}
	return err
}

// CheckAuthorization returns true if the user is holder of a role
func CheckAuthorization(namespace, email, resource, resourceName string) bool {
	authorized := false
	roleBindingRaw, _ := Clientset.RbacV1().RoleBindings(namespace).List(context.TODO(), metav1.ListOptions{})
	for _, roleBindingRow := range roleBindingRaw.Items {
		for _, subject := range roleBindingRow.Subjects {
			if subject.Kind == "User" && subject.Name == email {
				if roleBindingRow.RoleRef.Kind == "Role" {
					role, err := Clientset.RbacV1().Roles(namespace).Get(context.TODO(), roleBindingRow.RoleRef.Name, metav1.GetOptions{})
					if err == nil {
						for _, rule := range role.Rules {
							for _, ruleResource := range rule.Resources {
								if ruleResource == resource {
									if len(rule.ResourceNames) > 0 {
										for _, ruleResourceName := range rule.ResourceNames {
											if ruleResourceName == resourceName {
												authorized = true
											}
										}
									} else {
										authorized = true
									}
								}
							}
						}
					}
				} else if roleBindingRow.RoleRef.Kind == "ClusterRole" {
					role, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), roleBindingRow.RoleRef.Name, metav1.GetOptions{})
					if err == nil {
						for _, rule := range role.Rules {
							for _, ruleResource := range rule.Resources {
								if ruleResource == resource {
									if len(rule.ResourceNames) > 0 {
										for _, ruleResourceName := range rule.ResourceNames {
											if ruleResourceName == resourceName {
												authorized = true
											}
										}
									} else {
										authorized = true
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return authorized
}

// CreateUserSpecificRole user-specific roles regarding the resources of authority and users
func CreateUserSpecificRole(userCopy *apps_v1alpha.User, userOwnerNamespace *corev1.Namespace, userOwnerReferences []metav1.OwnerReference) error {
	policyRule := []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"authorities"}, ResourceNames: []string{userOwnerNamespace.Labels["authority-name"]},
		Verbs: []string{"get"}}, {APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"users"}, ResourceNames: []string{userCopy.GetName()}, Verbs: []string{"get", "update", "patch"}}}
	userRole := &rbacv1.Role{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("user-%s", userCopy.GetName()), OwnerReferences: userOwnerReferences},
		Rules: policyRule}
	_, err := Clientset.RbacV1().Roles(userCopy.GetNamespace()).Create(context.TODO(), userRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create user-%s role: %s", userCopy.GetName(), err)
		if errors.IsAlreadyExists(err) {
			currentUserRole, err := Clientset.RbacV1().Roles(userCopy.GetNamespace()).Get(context.TODO(), userRole.GetName(), metav1.GetOptions{})
			if err == nil {
				currentUserRole.Rules = policyRule
				_, err = Clientset.RbacV1().Roles(userCopy.GetNamespace()).Update(context.TODO(), currentUserRole, metav1.UpdateOptions{})
				if err == nil {
					log.Printf("User-%s role updated", userCopy.GetName())
					return err
				}
			}
		}
	}
	return err
}

// CreateUserAUPRole generates a dedicated role to allow the user access to accept/reject AUP, even if the AUP is expired
func CreateUserAUPRole(userCopy *apps_v1alpha.User, userOwnerReferences []metav1.OwnerReference) error {
	policyRule := []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"acceptableusepolicies", "acceptableusepolicies/status"}, ResourceNames: []string{userCopy.GetName()},
		Verbs: []string{"get", "update", "patch"}}}
	userRole := &rbacv1.Role{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("user-aup-%s", userCopy.GetName()), OwnerReferences: userOwnerReferences},
		Rules: policyRule}
	_, err := Clientset.RbacV1().Roles(userCopy.GetNamespace()).Create(context.TODO(), userRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create user-aup-%s role: %s", userCopy.GetName(), err)
		if errors.IsAlreadyExists(err) {
			currentUserRole, err := Clientset.RbacV1().Roles(userCopy.GetNamespace()).Get(context.TODO(), userRole.GetName(), metav1.GetOptions{})
			if err == nil {
				currentUserRole.Rules = policyRule
				_, err = Clientset.RbacV1().Roles(userCopy.GetNamespace()).Update(context.TODO(), currentUserRole, metav1.UpdateOptions{})
				if err == nil {
					log.Printf("User-aup-%s role updated", userCopy.GetName())
					return err
				}
			}
		}
	}
	return err
}

// CreateAUPRoleBinding links the AUP up with the user
func CreateAUPRoleBinding(userCopy *apps_v1alpha.User, userOwnerReferences []metav1.OwnerReference) error {
	// roleName to get user-specific AUP role which allows user to only get the AUP object related to itself
	roleName := fmt.Sprintf("user-aup-%s", userCopy.GetName())
	roleRef := rbacv1.RoleRef{Kind: "Role", Name: roleName}
	rbSubjects := []rbacv1.Subject{{Kind: "User", Name: userCopy.Spec.Email, APIGroup: "rbac.authorization.k8s.io"}}
	roleBind := &rbacv1.RoleBinding{ObjectMeta: metav1.ObjectMeta{Namespace: userCopy.GetNamespace(), Name: fmt.Sprintf("%s-%s", userCopy.GetNamespace(), roleName)},
		Subjects: rbSubjects, RoleRef: roleRef}
	roleBind.ObjectMeta.OwnerReferences = userOwnerReferences
	_, err := Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Create(context.TODO(), roleBind, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create user-aup-%s role: %s", userCopy.GetName(), err)
		if errors.IsAlreadyExists(err) {
			userRoleBind, err := Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Get(context.TODO(), roleBind.GetName(), metav1.GetOptions{})
			if err == nil {
				userRoleBind.Subjects = rbSubjects
				userRoleBind.RoleRef = roleRef
				_, err = Clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Update(context.TODO(), userRoleBind, metav1.UpdateOptions{})
				if err == nil {
					log.Printf("Completed: user-aup-%s role updated", userCopy.GetName())
					return err
				}
			}
		}
	}
	return err
}

// CreateAuthorityAdminRole generates roles for authority admins
func CreateAuthorityAdminRole() error {
	// Authority Admin
	policyRule := []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"users", "userregistrationrequests",
		"userregistrationrequests/status", "slices", "slices/status", "teams", "teams/status", "nodecontributions"}, Verbs: []string{"*"}},
		{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"acceptableusepolicies"}, Verbs: []string{"get", "list"}},
		{APIGroups: []string{"rbac.authorization.k8s.io"}, Resources: []string{"roles", "rolebindings"}, Verbs: []string{"*"}}}
	authorityRole := &rbacv1.ClusterRole{ObjectMeta: metav1.ObjectMeta{Name: "authority-admin"},
		Rules: policyRule}
	_, err := Clientset.RbacV1().ClusterRoles().Create(context.TODO(), authorityRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create authority-admin cluster role: %s", err)
		if errors.IsAlreadyExists(err) {
			authorityClusterRole, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), authorityRole.GetName(), metav1.GetOptions{})
			if err == nil {
				authorityClusterRole.Rules = policyRule
				_, err = Clientset.RbacV1().ClusterRoles().Update(context.TODO(), authorityClusterRole, metav1.UpdateOptions{})
				if err == nil {
					log.Println("Authority-admin cluster role updated")
					return err
				}
			}
		}
	}
	return err
}

// CreateAuthorityUserRole generates roles for authority users
func CreateAuthorityUserRole() error {
	// Authority User
	policyRule := []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"slices", "teams", "nodecontributions"}, Verbs: []string{"get", "list"}}}
	authorityRole := &rbacv1.ClusterRole{ObjectMeta: metav1.ObjectMeta{Name: "authority-user"},
		Rules: policyRule}
	_, err := Clientset.RbacV1().ClusterRoles().Create(context.TODO(), authorityRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create authority-user cluster role: %s", err)
		if errors.IsAlreadyExists(err) {
			authorityClusterRole, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), authorityRole.GetName(), metav1.GetOptions{})
			if err == nil {
				authorityClusterRole.Rules = policyRule
				_, err = Clientset.RbacV1().ClusterRoles().Update(context.TODO(), authorityClusterRole, metav1.UpdateOptions{})
				if err == nil {
					log.Println("Authority-user cluster role updated")
					return err
				}
			}
		}
	}
	return err
}

// CreateSliceRoles generated cluster roles for slices
func CreateSliceRoles() error {
	// Authority admin
	policyRule := []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"selectivedeployments"}, Verbs: []string{"*"}},
		{APIGroups: []string{""}, Resources: []string{"configmaps", "endpoints", "persistentvolumeclaims", "pods", "pods/exec", "pods/log", "replicationcontrollers", "services", "secrets"}, Verbs: []string{"*"}},
		{APIGroups: []string{"apps"}, Resources: []string{"daemonsets", "deployments", "replicasets", "statefulsets"}, Verbs: []string{"*"}},
		{APIGroups: []string{"autoscaling"}, Resources: []string{"horizontalpodautoscalers"}, Verbs: []string{"*"}},
		{APIGroups: []string{"batch"}, Resources: []string{"cronjobs", "jobs"}, Verbs: []string{"*"}},
		{APIGroups: []string{"extensions"}, Resources: []string{"daemonsets", "deployments", "ingresses", "networkpolicies", "replicasets", "replicationcontrollers"}, Verbs: []string{"*"}},
		{APIGroups: []string{"networking.k8s.io"}, Resources: []string{"ingresses", "networkpolicies"}, Verbs: []string{"*"}},
		{APIGroups: []string{""}, Resources: []string{"events", "controllerrevisions"}, Verbs: []string{"get", "list", "watch"}}}
	sliceRole := &rbacv1.ClusterRole{ObjectMeta: metav1.ObjectMeta{Name: "slice-admin"},
		Rules: policyRule}
	_, err := Clientset.RbacV1().ClusterRoles().Create(context.TODO(), sliceRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create slice-admin cluster role: %s", err)
		if errors.IsAlreadyExists(err) {
			sliceClusterRole, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), sliceRole.GetName(), metav1.GetOptions{})
			if err == nil {
				sliceClusterRole.Rules = policyRule
				_, err = Clientset.RbacV1().ClusterRoles().Update(context.TODO(), sliceClusterRole, metav1.UpdateOptions{})
				if err == nil {
					log.Println("Slice-admin cluster role updated")
				}
			}
		}
	}
	// Authority user
	sliceRole = &rbacv1.ClusterRole{ObjectMeta: metav1.ObjectMeta{Name: "slice-user"},
		Rules: policyRule}
	_, err = Clientset.RbacV1().ClusterRoles().Create(context.TODO(), sliceRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create slice-user cluster role: %s", err)
		if errors.IsAlreadyExists(err) {
			sliceClusterRole, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), sliceRole.GetName(), metav1.GetOptions{})
			if err == nil {
				sliceClusterRole.Rules = policyRule
				_, err = Clientset.RbacV1().ClusterRoles().Update(context.TODO(), sliceClusterRole, metav1.UpdateOptions{})
				if err == nil {
					log.Println("Slice-user cluster role updated")
					return err
				}
			}
		}
	}
	return err
}

// CreateTeamRoles generated cluster roles for teams
func CreateTeamRoles() error {
	// Authority admin
	policyRule := []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"slices", "slices/status"}, Verbs: []string{"*"}}}
	teamRole := &rbacv1.ClusterRole{ObjectMeta: metav1.ObjectMeta{Name: "team-admin"},
		Rules: policyRule}
	_, err := Clientset.RbacV1().ClusterRoles().Create(context.TODO(), teamRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create team-admin cluster role: %s", err)
		if errors.IsAlreadyExists(err) {
			teamClusterRole, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), teamRole.GetName(), metav1.GetOptions{})
			if err == nil {
				teamClusterRole.Rules = policyRule
				_, err = Clientset.RbacV1().ClusterRoles().Update(context.TODO(), teamClusterRole, metav1.UpdateOptions{})
				if err == nil {
					log.Println("Team-admin cluster role updated")
				}
			}
		}
	}
	// Authority user
	policyRule = []rbacv1.PolicyRule{{APIGroups: []string{"apps.edgenet.io"}, Resources: []string{"slices", "slices/status"}, Verbs: []string{"*"}}}
	teamRole = &rbacv1.ClusterRole{ObjectMeta: metav1.ObjectMeta{Name: "team-user"},
		Rules: policyRule}
	_, err = Clientset.RbacV1().ClusterRoles().Create(context.TODO(), teamRole, metav1.CreateOptions{})
	if err != nil {
		log.Printf("Couldn't create team-user cluster role: %s", err)
		if errors.IsAlreadyExists(err) {
			teamClusterRole, err := Clientset.RbacV1().ClusterRoles().Get(context.TODO(), teamRole.GetName(), metav1.GetOptions{})
			if err == nil {
				teamClusterRole.Rules = policyRule
				_, err = Clientset.RbacV1().ClusterRoles().Update(context.TODO(), teamClusterRole, metav1.UpdateOptions{})
				if err == nil {
					log.Println("Team-user cluster role updated")
					return err
				}
			}
		}
	}
	return err
}
