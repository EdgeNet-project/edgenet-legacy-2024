/*
Copyright 2019 Sorbonne Universit√©

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package registration

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"regexp"
	"strings"

	apps_v1alpha "headnode/pkg/apis/apps/v1alpha"
	"headnode/pkg/authorization"
	custconfig "headnode/pkg/config"
	"headnode/pkg/namespace"

	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/cert"
	kubeconfigutil "k8s.io/kubernetes/cmd/kubeadm/app/util/kubeconfig"
	cmdconfig "k8s.io/kubernetes/pkg/kubectl/cmd/config"
)

// CreateSpecificRoleBindings generates role bindings to allow users to access their user objects and the site to which they belong
func CreateSpecificRoleBindings(userCopy *apps_v1alpha.User) {
	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	// When a user is deleted, the owner references feature allows the related objects to be automatically removed
	userOwnerReferences := setOwnerReferences(userCopy)
	// Put the service account dedicated to the user into the role bind subjects
	rbSubjects := []rbacv1.Subject{{Kind: "ServiceAccount", Name: userCopy.GetName(), Namespace: userCopy.GetNamespace()}}
	// To put the web service account into the subjects if the user logged in
	if userCopy.Status.WebAuth {
		rbSubjectWebAuth := rbacv1.Subject{Kind: "ServiceAccount", Name: fmt.Sprintf("%s-webauth", userCopy.GetName()), Namespace: userCopy.GetNamespace()}
		rbSubjects = append(rbSubjects, rbSubjectWebAuth)
	}
	// This section allows the user to get user object that belongs to him. The role, which gets used by the binding object,
	// generated by the user controller when the user object created.
	roleName := fmt.Sprintf("user-%s", userCopy.GetName())
	roleRef := rbacv1.RoleRef{Kind: "Role", Name: roleName}
	roleBind := &rbacv1.RoleBinding{ObjectMeta: metav1.ObjectMeta{Namespace: userCopy.GetNamespace(), Name: fmt.Sprintf("%s-%s", userCopy.GetNamespace(), roleName),
		OwnerReferences: userOwnerReferences}, Subjects: rbSubjects, RoleRef: roleRef}
	_, err = clientset.RbacV1().RoleBindings(userCopy.GetNamespace()).Create(roleBind)
	if err != nil {
		log.Printf("Couldn't create %s role binding in namespace of %s: %s", roleName, userCopy.GetNamespace(), userCopy.GetName())
		log.Println(err.Error())
	}
	// This section allows the user to get the site object in which he/she participates. The role, which gets used by the binding object,
	// generated by the site controller when the site object created.
	userOwnerNamespace, _ := clientset.CoreV1().Namespaces().Get(userCopy.GetNamespace(), metav1.GetOptions{})
	roleName = fmt.Sprintf("site-%s", userOwnerNamespace.Labels["site-name"])
	roleRef = rbacv1.RoleRef{Kind: "ClusterRole", Name: roleName}
	clusterRoleBind := &rbacv1.ClusterRoleBinding{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("%s-%s-for-site", userCopy.GetNamespace(), userCopy.GetName()),
		OwnerReferences: userOwnerReferences}, Subjects: rbSubjects, RoleRef: roleRef}
	_, err = clientset.RbacV1().ClusterRoleBindings().Create(clusterRoleBind)
	if err != nil {
		log.Printf("Couldn't create %s role binding in namespace of %s: %s", roleName, userCopy.GetNamespace(), userCopy.GetName())
		log.Println(err.Error())
	}
}

// CreateRoleBindingsByRoles generates the rolebindings according to user roles in the namespace specified
func CreateRoleBindingsByRoles(userCopy *apps_v1alpha.User, namespace string, namespaceType string) {
	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	// When a user is deleted, the owner references feature allows the related objects to be automatically removed
	ownerReferences := setOwnerReferences(userCopy)
	// Put the service account dedicated to the user into the role bind subjects
	rbSubjects := []rbacv1.Subject{{Kind: "ServiceAccount", Name: userCopy.GetName(), Namespace: userCopy.GetNamespace()}}
	// To put the web service account into the subjects if the user logged in
	if userCopy.Status.WebAuth {
		rbSubjectWebAuth := rbacv1.Subject{Kind: "ServiceAccount", Name: fmt.Sprintf("%s-webauth", userCopy.GetName()), Namespace: userCopy.GetNamespace()}
		rbSubjects = append(rbSubjects, rbSubjectWebAuth)
	}
	// This loop creates role bindings depending on roles
	for _, userRole := range userCopy.Spec.Roles {
		// Roles are pre-generated by the controllers
		roleName := fmt.Sprintf("%s-%s", strings.ToLower(namespaceType), strings.ToLower(userRole))
		roleRef := rbacv1.RoleRef{Kind: "ClusterRole", Name: roleName}
		roleBind := &rbacv1.RoleBinding{ObjectMeta: metav1.ObjectMeta{Namespace: namespace, Name: fmt.Sprintf("%s-%s-%s", userCopy.GetNamespace(), userCopy.GetName(), roleName),
			OwnerReferences: ownerReferences}, Subjects: rbSubjects, RoleRef: roleRef}
		_, err = clientset.RbacV1().RoleBindings(namespace).Create(roleBind)
		if err != nil {
			log.Printf("Couldn't create %s role binding in namespace of %s: %s - %s", userRole, namespace, userCopy.GetNamespace(), userCopy.GetName())
			log.Println(err.Error())
		}
	}
}

// CreateServiceAccount makes a service account to serve the user. This functionality covers two types of service accounts
// in EdgeNet use, permanent for main use and temporary for web login.
func CreateServiceAccount(userCopy *apps_v1alpha.User, accountType string) (*corev1.ServiceAccount, error) {
	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	// Set the name of service account according to the type
	name := userCopy.GetName()
	if accountType == "webauth" {
		name = fmt.Sprintf("%s-%s", userCopy.GetName(), accountType)
	}
	ownerReferences := setOwnerReferences(userCopy)
	serviceAccount := &corev1.ServiceAccount{ObjectMeta: metav1.ObjectMeta{Name: name, OwnerReferences: ownerReferences}}
	serviceAccountCreated, err := clientset.CoreV1().ServiceAccounts(userCopy.GetNamespace()).Create(serviceAccount)
	if err != nil {
		log.Println(err.Error())
		return nil, err
	}
	return serviceAccountCreated, nil
}

// CreateSecretByPassword creates a secret that contains the user password as data
func CreateSecretByPassword(obj interface{}) string {
	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	// When a user is deleted, the owner references feature allows the related objects to be automatically removed
	ownerReferences := setOwnerReferences(obj)
	// secretName to update the user object's password field
	secretName := ""
	// createSecret function generates a secret by using the data of namespace, username, and password
	createSecret := func(namespace string, username string, password string) string {
		passwordSecret := &corev1.Secret{ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("%s-pass", username), Namespace: namespace}}
		passwordSecret.Data = map[string][]byte{"password": []byte(password)}
		passwordSecret.ObjectMeta.OwnerReferences = ownerReferences
		passwordSecretCreated, _ := clientset.CoreV1().Secrets(namespace).Create(passwordSecret)
		return passwordSecretCreated.GetName()
	}
	// This switch determines the object's type
	switch userObj := obj.(type) {
	case *apps_v1alpha.UserRegistrationRequest:
		secretName = createSecret(userObj.GetNamespace(), userObj.GetName(), userObj.Spec.Password)
	case *apps_v1alpha.User:
		secretName = createSecret(userObj.GetNamespace(), userObj.GetName(), userObj.Spec.Password)
	}
	return secretName
}

// CreateConfig checks serviceaccount of the user (actually, the namespace) to detect whether it contains the required.
// Then it gets that secret to use CA and token information. Subsequently, this reads cluster and server info of the current context
// from the config file to be consumed on the creation of kubeconfig.
func CreateConfig(serviceAccount *corev1.ServiceAccount) string {
	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	// To find out the secret name to use
	accountSecretName := ""
	for _, accountSecret := range serviceAccount.Secrets {
		match, _ := regexp.MatchString("([a-z0-9]+)-token-([a-z0-9]+)", accountSecret.Name)
		if match {
			accountSecretName = accountSecret.Name
			break
		}
	}
	// If there is no matching secret terminate this function as generating kubeconfig file is not possible
	if accountSecretName == "" {
		log.Printf("Serviceaccount %s in %s doesn't have a serviceaccount token", serviceAccount.GetName(), serviceAccount.GetNamespace())
		return fmt.Sprintf("Serviceaccount %s doesn't have a serviceaccount token\n", serviceAccount.GetName())
	}
	secret, err := clientset.CoreV1().Secrets(serviceAccount.GetNamespace()).Get(accountSecretName, metav1.GetOptions{})
	if errors.IsNotFound(err) {
		log.Printf("Secret for %s in %s not found", serviceAccount.GetName(), serviceAccount.GetNamespace())
		return fmt.Sprintf("Secret %s not found\n", serviceAccount.GetName())
	} else if statusError, isStatus := err.(*errors.StatusError); isStatus {
		log.Printf("Error getting secret %s in %s: %v", serviceAccount.GetName(), serviceAccount.GetNamespace(), statusError.ErrStatus)
		return fmt.Sprintf("Error getting secret %s: %v\n", serviceAccount.GetName(), statusError.ErrStatus)
	} else if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	// Define the cluster and server by taking advantage of the current config file
	cluster, server, err := custconfig.GetClusterServerOfCurrentContext()
	if err != nil {
		log.Println(err)
		return fmt.Sprintf("Err: %s", err)
	}
	// Put the collected data into new kubeconfig file
	newKubeConfig := kubeconfigutil.CreateWithToken(server, cluster, serviceAccount.GetName(), secret.Data["ca.crt"], string(secret.Data["token"]))
	newKubeConfig.Contexts[newKubeConfig.CurrentContext].Namespace = serviceAccount.GetNamespace()
	kubeconfigutil.WriteToDisk(fmt.Sprintf("../../assets/kubeconfigs/edgenet-%s-%s.cfg", serviceAccount.GetNamespace(), serviceAccount.GetName()), newKubeConfig)
	// Check whether the creation process is completed
	dat, err := ioutil.ReadFile(fmt.Sprintf("../../assets/kubeconfigs/edgenet-%s-%s.cfg", serviceAccount.GetNamespace(), serviceAccount.GetName()))
	if err != nil {
		log.Println(err)
		return fmt.Sprintf("Err: %s", err)
	}
	return string(dat)
}

// setOwnerReferences put the user or userregistrationrequest as owner
func setOwnerReferences(objCopy interface{}) []metav1.OwnerReference {
	ownerReferences := []metav1.OwnerReference{}
	newReference := metav1.OwnerReference{}
	switch userObj := objCopy.(type) {
	case *apps_v1alpha.UserRegistrationRequest:
		newReference = *metav1.NewControllerRef(userObj, apps_v1alpha.SchemeGroupVersion.WithKind("UserRegistrationRequest"))
	case *apps_v1alpha.User:
		newReference = *metav1.NewControllerRef(userObj, apps_v1alpha.SchemeGroupVersion.WithKind("User"))
	}
	takeControl := false
	newReference.Controller = &takeControl
	ownerReferences = append(ownerReferences, newReference)
	return ownerReferences
}

// MakeUser generates key and certificate and then set credentials into the config file. As the next step,
// this function creates user role and role bindings for the namespace. Lastly, this checks the namespace
// created successfully or not.
func MakeUser(user string) ([]byte, int) {
	userNamespace, err := namespace.Create(user)
	if err != nil {
		log.Printf("Namespace %s couldn't be created.", user)
		resultMap := map[string]string{"status": "Failure"}
		result, _ := json.Marshal(resultMap)
		return result, 500
	}
	cert.GenerateSelfSignedCertKeyWithFixtures(userNamespace, nil, nil, "../../assets/certs")
	pathOptions := clientcmd.NewDefaultPathOptions()
	buf := bytes.NewBuffer([]byte{})
	kcmd := cmdconfig.NewCmdConfigSetAuthInfo(buf, pathOptions)
	kcmd.SetArgs([]string{user})
	kcmd.Flags().Parse([]string{
		fmt.Sprintf("--client-certificate=../../assets/certs/%s__.crt", user),
		fmt.Sprintf("--client-key=../../assets/certs/%s__.key", user),
	})

	if err := kcmd.Execute(); err != nil {
		log.Printf("Couldn't set auth info on the kubeconfig file: %s", user)
		resultMap := map[string]string{"status": "Failure"}
		result, _ := json.Marshal(resultMap)
		return result, 500
	}

	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}

	rbSubjects := []rbacv1.Subject{{Kind: "ServiceAccount", Name: "default", Namespace: user}}
	roleBindRef := rbacv1.RoleRef{Kind: "ClusterRole", Name: "admin"}
	var roleBind *rbacv1.RoleBinding
	roleBind = &rbacv1.RoleBinding{ObjectMeta: metav1.ObjectMeta{Namespace: user, Name: fmt.Sprintf("%s", user)},
		Subjects: rbSubjects, RoleRef: roleBindRef}
	_, err = clientset.RbacV1().RoleBindings(user).Create(roleBind)
	if err != nil {
		log.Printf("Couldn't create user admin role binding: %s", user)
		resultMap := map[string]string{"status": "Failure"}
		result, _ := json.Marshal(resultMap)
		return result, 500
	}

	rbSubjectsEdgenet := []rbacv1.Subject{{Kind: "ServiceAccount", Name: "default", Namespace: user}}
	roleBindRefEdgenet := rbacv1.RoleRef{Kind: "ClusterRole", Name: "edgenet-admin"}
	var roleBindEdgenet *rbacv1.RoleBinding
	roleBindEdgenet = &rbacv1.RoleBinding{ObjectMeta: metav1.ObjectMeta{Namespace: user, Name: fmt.Sprintf("%s-edgenet", user)},
		Subjects: rbSubjectsEdgenet, RoleRef: roleBindRefEdgenet}
	_, err = clientset.RbacV1().RoleBindings(user).Create(roleBindEdgenet)
	if err != nil {
		log.Printf("Couldn't create user admin role binding: %s", user)
		resultMap := map[string]string{"status": "Failure"}
		result, _ := json.Marshal(resultMap)
		return result, 500
	}

	exist, err := namespace.GetNamespaceByName(user)
	if err == nil && exist == "true" {
		resultMap := map[string]string{"status": "Acknowledged"}
		result, _ := json.Marshal(resultMap)
		return result, 200
	}

	log.Printf("Namespace couldn't be created: %s", user)
	resultMap := map[string]string{"status": "Failure"}
	result, _ := json.Marshal(resultMap)
	return result, 500
}

// MakeConfig checks/gets serviceaccount of the user (actually, the namespace), and if the serviceaccount exists
// this function checks/gets its secret, and then CA and token info of the secret. Subsequently, this reads cluster
// and server info of the current context from the config file to use them on the creation of kubeconfig.
func MakeConfig(user string) string {
	clientset, err := authorization.CreateClientSet()
	if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}

	serviceAccount, err := clientset.CoreV1().ServiceAccounts(user).Get("default", metav1.GetOptions{})
	if errors.IsNotFound(err) {
		log.Printf("Serviceaccount %s not found", user)
		return fmt.Sprintf("Serviceaccount %s not found\n", user)
	} else if statusError, isStatus := err.(*errors.StatusError); isStatus {
		log.Printf("Error getting serviceaccount %s: %v", user, statusError.ErrStatus)
		return fmt.Sprintf("Error getting serviceaccount %s: %v\n", user, statusError.ErrStatus)
	} else if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}
	accountSecret := serviceAccount.Secrets[0].Name
	if accountSecret == "" {
		log.Printf("Serviceaccount %s doesn't have a serviceaccount token", user)
		return fmt.Sprintf("Serviceaccount %s doesn't have a serviceaccount token\n", user)
	}

	secret, err := clientset.CoreV1().Secrets(user).Get(accountSecret, metav1.GetOptions{})
	if errors.IsNotFound(err) {
		log.Printf("Secret %s not found", user)
		return fmt.Sprintf("Secret %s not found\n", user)
	} else if statusError, isStatus := err.(*errors.StatusError); isStatus {
		log.Printf("Error getting secret %s: %v", user, statusError.ErrStatus)
		return fmt.Sprintf("Error getting secret %s: %v\n", user, statusError.ErrStatus)
	} else if err != nil {
		log.Println(err.Error())
		panic(err.Error())
	}

	cluster, server, err := custconfig.GetClusterServerOfCurrentContext()
	if err != nil {
		log.Println(err)
		return fmt.Sprintf("Err: %s", err)
	}

	newKubeConfig := kubeconfigutil.CreateWithToken(server, cluster, "default", secret.Data["ca.crt"], string(secret.Data["token"]))
	newKubeConfig.Contexts[newKubeConfig.CurrentContext].Namespace = user
	newKubeConfig.Contexts["kubernetes-admin@kubernetes"] = newKubeConfig.Contexts[newKubeConfig.CurrentContext]
	delete(newKubeConfig.Contexts, newKubeConfig.CurrentContext)
	newKubeConfig.CurrentContext = "kubernetes-admin@kubernetes"
	kubeconfigutil.WriteToDisk(fmt.Sprintf("../../assets/kubeconfigs/edgenet_%s.cfg", user), newKubeConfig)

	dat, err := ioutil.ReadFile(fmt.Sprintf("../../assets/kubeconfigs/edgenet_%s.cfg", user))
	if err != nil {
		log.Println(err)
		return fmt.Sprintf("Err: %s", err)
	}
	return string(dat)
}
